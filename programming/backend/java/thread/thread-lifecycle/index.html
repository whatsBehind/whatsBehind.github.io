<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Thread Lifecycle | What&#39;s Behind</title>
<meta name="keywords" content="">
<meta name="description" content="Understanding the lifecycle of a thread is crucial for effective thread management. Here&rsquo;s a breakdown:
NEW State:
When you create an instance of a Thread class (or a class that extends Thread), the thread is in the New state. At this point, the thread is not yet running. Example: Thread t = new Thread(); RUNNABLE State:
When you invoke the start() method, the thread moves to the RUNNABLE state. A thread in the RUNNABLE state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.">
<meta name="author" content="">
<link rel="canonical" href="https://whatsBehind.github.io/programming/backend/java/thread/thread-lifecycle/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://whatsBehind.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://whatsBehind.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://whatsBehind.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://whatsBehind.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://whatsBehind.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Thread Lifecycle" />
<meta property="og:description" content="Understanding the lifecycle of a thread is crucial for effective thread management. Here&rsquo;s a breakdown:
NEW State:
When you create an instance of a Thread class (or a class that extends Thread), the thread is in the New state. At this point, the thread is not yet running. Example: Thread t = new Thread(); RUNNABLE State:
When you invoke the start() method, the thread moves to the RUNNABLE state. A thread in the RUNNABLE state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whatsBehind.github.io/programming/backend/java/thread/thread-lifecycle/" /><meta property="article:section" content="programming" />
<meta property="article:published_time" content="2023-11-12T23:12:57-08:00" />
<meta property="article:modified_time" content="2023-11-12T23:12:57-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Thread Lifecycle"/>
<meta name="twitter:description" content="Understanding the lifecycle of a thread is crucial for effective thread management. Here&rsquo;s a breakdown:
NEW State:
When you create an instance of a Thread class (or a class that extends Thread), the thread is in the New state. At this point, the thread is not yet running. Example: Thread t = new Thread(); RUNNABLE State:
When you invoke the start() method, the thread moves to the RUNNABLE state. A thread in the RUNNABLE state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Programmings",
      "item": "https://whatsBehind.github.io/programming/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Thread Lifecycle",
      "item": "https://whatsBehind.github.io/programming/backend/java/thread/thread-lifecycle/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Thread Lifecycle",
  "name": "Thread Lifecycle",
  "description": "Understanding the lifecycle of a thread is crucial for effective thread management. Here\u0026rsquo;s a breakdown:\nNEW State:\nWhen you create an instance of a Thread class (or a class that extends Thread), the thread is in the New state. At this point, the thread is not yet running. Example: Thread t = new Thread(); RUNNABLE State:\nWhen you invoke the start() method, the thread moves to the RUNNABLE state. A thread in the RUNNABLE state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.",
  "keywords": [
    
  ],
  "articleBody": "Understanding the lifecycle of a thread is crucial for effective thread management. Here’s a breakdown:\nNEW State:\nWhen you create an instance of a Thread class (or a class that extends Thread), the thread is in the New state. At this point, the thread is not yet running. Example: Thread t = new Thread(); RUNNABLE State:\nWhen you invoke the start() method, the thread moves to the RUNNABLE state. A thread in the RUNNABLE state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor. RUNNING State:\nThread doesn’t have this state. It still belongs to RUNNABLE state in Java, but it was running on processor. A thread is in the RUNNING state when the thread scheduler selects it from the runnable pool. In this state, the run() method’s body is being executed. BLOCKED State:\nThread state for a thread blocked waiting for a monitor lock. A thread in the BLOCKED state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait. WAITING State:\nThread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods: Thread.sleep Object.wait WITHOUT timeout Thread.join WITHOUT timeout TIMED_WAITING State:\nThread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time: Object.wait WITH timeout Thread.join WITH timeout TERMINATED State:\nA thread enters the TERMINATED state when it completes the execution of its run() method or if an exception occurs. Once terminated, a thread cannot be restarted. Common Thread Methods Here are some commonly used methods in the Thread class:\nstart():\nInitiates the execution of the thread and calls the run() method. The thread transitions from New to Runnable state. run():\nContains the code that is executed by the thread. You override this method when creating a thread. sleep(long millis):\nCauses the current thread to pause execution for a specified period. This is a static method. join():\nUsed to pause the execution of the current thread until the thread it joins with completes its execution. yield():\nA static method that pauses the currently executing thread to give a chance for other threads of the same priority to execute. It’s a way of telling the thread scheduler that the current thread is willing to “step back” if there are other threads that should run. However, the scheduler is free to ignore this hint. interrupt():\nInterrupts the thread, which is in the sleeping or waiting state, causing it to throw an InterruptedException. Practical Example Let’s look at a simple example to demonstrate some of these concepts: public class ThreadLifeCycle { public static void main(String[] args) throws InterruptedException { LifeCycleThread thread = new LifeCycleThread(); System.out.println(\"State of a new Thread: \" + thread.getState()); thread.start(); Thread.sleep(50); System.out.println(\"LifeCycleThread is sleeping. Thread state: \" + thread.getState()); Thread.sleep(120); System.out.println(\"LifeCycleThread finished. Thread state: \" + thread.getState()); } } class LifeCycleThread extends Thread { public void run() { System.out.println(\"Thread started. Thread state: \" + this.getState()); try { Thread.sleep(100); } catch (InterruptedException e) { throw new RuntimeException(e); } } } /* * Executing results: * State of a new Thread: NEW * Thread started. Thread state: RUNNABLE * LifeCycleThread is sleeping. Thread state: TIMED_WAITING * LifeCycleThread finished. Thread state: TERMINATED * */ Example of join() We defined an OuterThead, and inside it we defined an InnerThread. run() method in InterThread is simple, just sleeping for 100ms. In run() method of OuterThread, it starts an InterThread and right after that it invokes join() from InnerThread, which means OuterThread will wait here (WAITING state) until InnerThread finishes. In main thread, we start an outerThread, and print the states of OuterThread and InnerThread.\npublic class Join_ { public static void main(String[] args) throws InterruptedException { OuterThread outerThread = new OuterThread(); outerThread.setName(\"OuterThread\"); outerThread.start(); Thread.sleep(50); Thread innerThread = outerThread.getInnerThread(); System.out.println(\"InnerThread state: \" + innerThread.getState()); System.out.println(\"OuterThread state: \" + outerThread.getState()); } } class OuterThread extends Thread { Thread innerThread = new Thread(new InnerThread(), \"InnerThread\"); public void run() { innerThread.start(); try { innerThread.join(); } catch (InterruptedException e) { throw new RuntimeException(e); } } public Thread getInnerThread() { return innerThread; } class InnerThread implements Runnable { public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } /* * Executing results * InnerThread state: TIMED_WAITING * OuterThread state: WAITING * */ Example of interrupt() public class Interrupt_ { public static void main(String[] args) throws InterruptedException { InterruptThread thread = new InterruptThread(); thread.start(); Thread.sleep(10); System.out.println(\"InterruptThread state: \" + thread.getState()); thread.interrupt(); Thread.sleep(10); System.out.println(\"InterruptThread was interrupted. Thread state: \" + thread.getState()); } } class InterruptThread extends Thread { @Override public void run() { try { System.out.println(\"InterruptThread is sleep\"); Thread.sleep(100); } catch (InterruptedException e) { System.out.println(\"InterruptThread was interrupted\"); } } } /* * Executing results: * InterruptThread is sleep * InterruptThread state: TIMED_WAITING * InterruptThread was interrupted * InterruptThread was interrupted. Thread state: TERMINATED * */ Example of BLOCKED state public class BlockedState { public static void main(String[] args) throws InterruptedException { BlockedStateThread thread1 = new BlockedStateThread(); BlockedStateThread thread2 = new BlockedStateThread(); thread1.setName(\"Thread1\"); thread2.setName(\"Thread2\"); thread1.start(); thread2.start(); Thread.sleep(50); System.out.println(\"Thread1 state: \" + thread1.getState()); System.out.println(\"Thread2 state: \" + thread2.getState()); } } class BlockedStateThread extends Thread { static int count = 0; @Override public void run() { synchronized (BlockedStateThread.class) { System.out.println(\"Which thread has the lock now: \" + Thread.currentThread().getName()); try { Thread.sleep(100); } catch (InterruptedException e) { throw new RuntimeException(e); } count++; } } } /* * Executing results: * Which thread has the lock now: Thread1 * Thread1 state: TIMED_WAITING * Thread2 state: BLOCKED * Which thread has the lock now: Thread2 * */ ",
  "wordCount" : "953",
  "inLanguage": "en",
  "datePublished": "2023-11-12T23:12:57-08:00",
  "dateModified": "2023-11-12T23:12:57-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://whatsBehind.github.io/programming/backend/java/thread/thread-lifecycle/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "What's Behind",
    "logo": {
      "@type": "ImageObject",
      "url": "https://whatsBehind.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://whatsBehind.github.io/" accesskey="h" title="What&#39;s Behind (Alt + H)">What&#39;s Behind</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Thread Lifecycle
    </h1>
    <div class="post-meta"><span title='2023-11-12 23:12:57 -0800 PST'>November 12, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Understanding the lifecycle of a thread is crucial for effective thread management. Here&rsquo;s a breakdown:</p>
<ul>
<li>
<p><code>NEW</code> State:</p>
<ul>
<li>When you create an instance of a <code>Thread</code> class (or a class that extends <code>Thread</code>), the thread is in the <code>New</code> state.</li>
<li>At this point, the thread is not yet running.</li>
<li>Example: <code>Thread t = new Thread();</code></li>
</ul>
</li>
<li>
<p><code>RUNNABLE</code> State:</p>
<ul>
<li>When you invoke the <code>start()</code> method, the thread moves to the <code>RUNNABLE</code> state.</li>
<li>A thread in the <code>RUNNABLE</code> state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</li>
</ul>
</li>
<li>
<p><code>RUNNING</code> State:</p>
<ul>
<li><code>Thread</code> doesn&rsquo;t have this state. It still belongs to <code>RUNNABLE</code> state in Java, but it was running on processor.</li>
<li>A thread is in the <code>RUNNING</code> state when the thread scheduler selects it from the runnable pool.</li>
<li>In this state, the <code>run()</code> method&rsquo;s body is being executed.</li>
</ul>
</li>
<li>
<p><code>BLOCKED</code> State:</p>
<ul>
<li>Thread state for a thread blocked waiting for a monitor lock. A thread in the <code>BLOCKED</code> state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling <code>Object.wait</code>.</li>
</ul>
</li>
<li>
<p><code>WAITING</code> State:</p>
<ul>
<li>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:
<ul>
<li><code>Thread.sleep</code></li>
<li><code>Object.wait</code> <strong>WITHOUT</strong> timeout</li>
<li><code>Thread.join</code> <strong>WITHOUT</strong> timeout</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>TIMED_WAITING</code> State:</p>
<ul>
<li>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:
<ul>
<li><code>Object.wait</code> <strong>WITH</strong> timeout</li>
<li><code>Thread.join</code> <strong>WITH</strong> timeout</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>TERMINATED</code> State:</p>
<ul>
<li>A thread enters the <code>TERMINATED</code> state when it completes the execution of its <code>run()</code> method or if an exception occurs.</li>
<li>Once terminated, a thread cannot be restarted.</li>
</ul>
</li>
</ul>
<h1 id="common-thread-methods">Common Thread Methods<a hidden class="anchor" aria-hidden="true" href="#common-thread-methods">#</a></h1>
<p>Here are some commonly used methods in the Thread class:</p>
<ul>
<li>
<p><code>start()</code>:</p>
<ul>
<li>Initiates the execution of the thread and calls the <code>run()</code> method.</li>
<li>The thread transitions from New to Runnable state.</li>
</ul>
</li>
<li>
<p><code>run()</code>:</p>
<ul>
<li>Contains the code that is executed by the thread.</li>
<li>You override this method when creating a thread.</li>
</ul>
</li>
<li>
<p><code>sleep(long millis)</code>:</p>
<ul>
<li>Causes the current thread to pause execution for a specified period.</li>
<li>This is a static method.</li>
</ul>
</li>
<li>
<p><code>join()</code>:</p>
<ul>
<li>Used to pause the execution of the current thread until the thread it joins with completes its execution.</li>
</ul>
</li>
<li>
<p><code>yield()</code>:</p>
<ul>
<li>A static method that pauses the currently executing thread to give a chance for other threads of the same priority to execute. It&rsquo;s a way of telling the thread scheduler that the current thread is willing to &ldquo;step back&rdquo; if there are other threads that should run. However, the scheduler is free to ignore this hint.</li>
</ul>
</li>
<li>
<p><code>interrupt()</code>:</p>
<ul>
<li>Interrupts the thread, which is in the sleeping or waiting state, causing it to throw an <code>InterruptedException</code>.</li>
</ul>
</li>
</ul>
<h2 id="practical-example">Practical Example<a hidden class="anchor" aria-hidden="true" href="#practical-example">#</a></h2>
<ul>
<li>Let&rsquo;s look at a simple example to demonstrate some of these concepts:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadLifeCycle</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        LifeCycleThread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LifeCycleThread();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;State of a new Thread: &#34;</span> <span style="color:#f92672">+</span> thread.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>        thread.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(50);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;LifeCycleThread is sleeping. Thread state: &#34;</span> <span style="color:#f92672">+</span> thread.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(120);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;LifeCycleThread finished. Thread state: &#34;</span> <span style="color:#f92672">+</span> thread.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LifeCycleThread</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Thread started. Thread state: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(100);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* Executing results:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* State of a new Thread: NEW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* Thread started. Thread state: RUNNABLE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* LifeCycleThread is sleeping. Thread state: TIMED_WAITING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* LifeCycleThread finished. Thread state: TERMINATED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* */</span>
</span></span></code></pre></div><ul>
<li>Example of <code>join()</code></li>
</ul>
<p>We defined an <code>OuterThead</code>, and inside it we defined an <code>InnerThread</code>. <code>run()</code> method in <code>InterThread</code> is simple, just sleeping for 100ms. In <code>run()</code> method of <code>OuterThread</code>, it starts an <code>InterThread</code> and right after that it invokes <code>join()</code> from <code>InnerThread</code>, which means <code>OuterThread</code> will wait here (<code>WAITING</code> state) until <code>InnerThread</code> finishes.
In <code>main</code> thread, we start an <code>outerThread</code>, and print the states of <code>OuterThread</code> and <code>InnerThread</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Join_</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        OuterThread outerThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OuterThread();
</span></span><span style="display:flex;"><span>        outerThread.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;OuterThread&#34;</span>);
</span></span><span style="display:flex;"><span>        outerThread.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(50);
</span></span><span style="display:flex;"><span>        Thread innerThread <span style="color:#f92672">=</span> outerThread.<span style="color:#a6e22e">getInnerThread</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;InnerThread state: &#34;</span> <span style="color:#f92672">+</span> innerThread.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;OuterThread state: &#34;</span> <span style="color:#f92672">+</span> outerThread.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OuterThread</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>    Thread innerThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(<span style="color:#66d9ef">new</span> InnerThread(), <span style="color:#e6db74">&#34;InnerThread&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        innerThread.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            innerThread.<span style="color:#a6e22e">join</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Thread <span style="color:#a6e22e">getInnerThread</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> innerThread;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerThread</span> <span style="color:#66d9ef">implements</span> Runnable {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#a6e22e">sleep</span>(100);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Executing results
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * InnerThread state: TIMED_WAITING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * OuterThread state: WAITING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * */</span>
</span></span></code></pre></div><ul>
<li>Example of <code>interrupt()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Interrupt_</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        InterruptThread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InterruptThread();
</span></span><span style="display:flex;"><span>        thread.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(10);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;InterruptThread state: &#34;</span> <span style="color:#f92672">+</span> thread.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>        thread.<span style="color:#a6e22e">interrupt</span>();
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(10);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;InterruptThread was interrupted. Thread state: &#34;</span> <span style="color:#f92672">+</span> thread.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InterruptThread</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;InterruptThread is sleep&#34;</span>);
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">sleep</span>(100);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;InterruptThread was interrupted&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* Executing results:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* InterruptThread is sleep
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* InterruptThread state: TIMED_WAITING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* InterruptThread was interrupted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* InterruptThread was interrupted. Thread state: TERMINATED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* */</span>
</span></span></code></pre></div><ul>
<li>Example of <code>BLOCKED</code> state</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BlockedState</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        BlockedStateThread thread1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BlockedStateThread();
</span></span><span style="display:flex;"><span>        BlockedStateThread thread2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BlockedStateThread();
</span></span><span style="display:flex;"><span>        thread1.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;Thread1&#34;</span>);
</span></span><span style="display:flex;"><span>        thread2.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;Thread2&#34;</span>);
</span></span><span style="display:flex;"><span>        thread1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        thread2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(50);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Thread1 state: &#34;</span> <span style="color:#f92672">+</span> thread1.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Thread2 state: &#34;</span> <span style="color:#f92672">+</span> thread2.<span style="color:#a6e22e">getState</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BlockedStateThread</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (BlockedStateThread.<span style="color:#a6e22e">class</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Which thread has the lock now: &#34;</span> <span style="color:#f92672">+</span> Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#a6e22e">sleep</span>(100);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Executing results:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Which thread has the lock now: Thread1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Thread1 state: TIMED_WAITING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Thread2 state: BLOCKED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Which thread has the lock now: Thread2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * */</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://whatsBehind.github.io/">What&#39;s Behind</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
