<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Online Chat | What&#39;s Behind</title>
<meta name="keywords" content="">
<meta name="description" content="Demo High Level Architecture This is an online chat system built with BIO (Blocking IO) Using Java. Each client has two socket connections with the server, one connection supports message push mode and another one supports message pull mode.
The system now supports below features:
Login Pull online users Online chat Logoff Because of supports for push and pull modes, features like
Upload/Download files Group chat can be easily added in the system.">
<meta name="author" content="">
<link rel="canonical" href="https://whatsBehind.github.io/programming/project/online-chat/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://whatsBehind.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://whatsBehind.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://whatsBehind.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://whatsBehind.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://whatsBehind.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Online Chat" />
<meta property="og:description" content="Demo High Level Architecture This is an online chat system built with BIO (Blocking IO) Using Java. Each client has two socket connections with the server, one connection supports message push mode and another one supports message pull mode.
The system now supports below features:
Login Pull online users Online chat Logoff Because of supports for push and pull modes, features like
Upload/Download files Group chat can be easily added in the system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whatsBehind.github.io/programming/project/online-chat/" /><meta property="article:section" content="programming" />
<meta property="article:published_time" content="2023-11-26T21:26:33-08:00" />
<meta property="article:modified_time" content="2023-11-26T21:26:33-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Online Chat"/>
<meta name="twitter:description" content="Demo High Level Architecture This is an online chat system built with BIO (Blocking IO) Using Java. Each client has two socket connections with the server, one connection supports message push mode and another one supports message pull mode.
The system now supports below features:
Login Pull online users Online chat Logoff Because of supports for push and pull modes, features like
Upload/Download files Group chat can be easily added in the system."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Programmings",
      "item": "https://whatsBehind.github.io/programming/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Online Chat",
      "item": "https://whatsBehind.github.io/programming/project/online-chat/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Online Chat",
  "name": "Online Chat",
  "description": "Demo High Level Architecture This is an online chat system built with BIO (Blocking IO) Using Java. Each client has two socket connections with the server, one connection supports message push mode and another one supports message pull mode.\nThe system now supports below features:\nLogin Pull online users Online chat Logoff Because of supports for push and pull modes, features like\nUpload/Download files Group chat can be easily added in the system.",
  "keywords": [
    
  ],
  "articleBody": "Demo High Level Architecture This is an online chat system built with BIO (Blocking IO) Using Java. Each client has two socket connections with the server, one connection supports message push mode and another one supports message pull mode.\nThe system now supports below features:\nLogin Pull online users Online chat Logoff Because of supports for push and pull modes, features like\nUpload/Download files Group chat can be easily added in the system. However, this project is just for learning purpose, so I didn’t spend too much time on it. Key Components Client Server Listener It’s basically a class extending Thread containing a socket connected with the server. In its run() method, it listens to InputStream of the socket which takes messages from the server. The socket in this component connects to Publisher from the server to support message push mode\npublic class ServerListener extends Thread { private Socket socket; private boolean listening = true; public ServerListener(Socket socket, User user) { this.socket = socket; this.user = user; } public void run() { try { while(listening) { ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); Message response = (Message) ois.readObject(); MessageType type = response.getType(); switch(type) { ... // Operations } } } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } Online Chat Client It’s a client class containing another socket connecting with the server. It supports message pull mode, which is that client sends a request to server and receives a response, and it’s a synchronous request. It has two private methods sendRequest and receiveResponse which are used to support communication with the server.\npublic class OnlineChatClient { private Socket client; private ObjectOutputStream oos; private ObjectInputStream ois; private void sendRequest(Message request) throws IOException { oos = new ObjectOutputStream(client.getOutputStream()); oos.writeObject(request); } private Message receiveResponse() throws IOException, ClassNotFoundException { ois = new ObjectInputStream(client.getInputStream()); return (Message) ois.readObject(); } } Server Message Publisher The name of this component is descriptive. Its duty is to publish a message to a corresponding client and receive the response from the server. It works with Server Listener in clients to support message push mode. Each message publisher has a 1 to 1 relationship with the client. All message publishers are managed by Message Publisher Manager\npublic class MessagePublisher { private Socket socket; private ObjectOutputStream oos; public void publish(Object o) throws IOException { oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(o); } } Message Publisher Manager It maintains a Map to store all message publishers. The map’s key is user id and the value is the message publisher. It provides methods like add() get(String userId) and delete(String userId) to manage all message publishers.\npublic class MessagePublisherManager { private final static Map\u003cString, MessagePublisher\u003e publishers = new ConcurrentHashMap\u003c\u003e(); public static boolean contains(User user) { final String id = user.getId(); return publishers.containsKey(id); } public static MessagePublisher add(User user, Socket socket) { if (contains(user)) { return publishers.get(user); } final String id = user.getId(); MessagePublisher publisher = new MessagePublisher(user, socket); return MessagePublisherManager.publishers.put(id, publisher); } public static MessagePublisher get(String userId) { return publishers.get(userId); } public static MessagePublisher get(User user) { return get(user.getId()); } public static void remove(User user) { publishers.remove(user.getId()); } } Client Listener It is similar to Server Listener in clients. It’s a Thread subclass waiting for message from the server. The thread in the most time is blocked at line\nMessage response = (Message) ois.readObject(); Once messages sent to the socket’s receive queue (InputStream), it reads the message and performs corresponding operation and returns a response to the client.\npublic class ClientListener extends Thread { private Socket socket; private ObjectOutputStream oos; private boolean listening = true; public void run() { try { while(listening) { ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); Message response = (Message) ois.readObject(); MessageType type = response.getType(); switch(type) { ... // Operations } } } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } private void sendResponse(Message message) throws IOException { oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message); } } Client Listener Manager It manages all client listeners in a Map, supporting methods like add, get and remove.\npublic class ClientListenerManager { private final static Map\u003cString, ClientListener\u003e clientListeners = new ConcurrentHashMap\u003c\u003e(); private static ObjectOutputStream oos; public static void add(Socket socket, User user) throws IOException { Message response = Message.builder() .type(MessageType.CONNECT) .content(gson.toJson(BaseResponse.builder().successful(true).build())) .timeStamp(new Date().toString()).build(); oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(response); ClientListener listener = new ClientListener(socket, user); clientListeners.put(user.getId(), listener); listener.start(); } public static ClientListener get(User user) { final String id = user.getId(); return clientListeners.get(id); } public static ClientListener get(String id) { return clientListeners.get(id); } public static void remove(User user) { final String id = user.getId(); clientListeners.remove(id); } } Supported Features Login Client creates a new Socket connecting to port 9999 in local host (Server and clients are in local host) by sending below message. Message type is USER_LOGIN Before sending the message, user needs to enter user id and password Message request = Message.builder() .sender(user.getId()) .timeStamp(new Date().toString()) .type(MessageType.USER_LOGIN) .content(gson.toJson(user)) .build(); Server receives the login message from the client First server checks database if the user enters valid user id and password (Not implemented) After id and password validations, server creates a new MessagePublisher and add it into MessagePublisherManager In the end, server sends back a response to notify the client if login succeeds Client receives response from server. If login succeeded, client start a new ServerListener which is a subclass of Thread to listen to message from server. The thread is blocked when there is no messages from server. Connect: This is not an API, but a process implicitly done in advance for features like GetOnlineUsers which utilizes OnlineChatClient\nClient creates a new Socket connecting to port 9999 in local host After server receives the request, it starts a new ClientListener, the subclass of Thread, which is listening message from the client. Then server add the ClientListener to ClientListenerManager Server send back response to the client Client receives response from server After above steps, a new socket connection between server and client is built, which supports message pull mode.\nGetOnlineUsers Client sends a request to server Server checks MessagePublisherManager, get all online users’ id Server sends a response back to client Client renders online users’ id in terminal Chat ClientA sends a request to server containing receiver’s id (ClientB) and the message Client listenerA in the server receives the request, it passes the message to message publisherB Message publisherB sends a request containing the message to clientB ClientB responds after receiving the message After message was successfully sent to clientB, client listenerA sends a response to clientA ClientA receives the response Logoff Client sends a request to the server to logoff Server receives the request, responds to the client. Server close the socket in the client listener, and remove the listener from listener manager Server sends a request to client through message publisher Client receives the request, close socket in the server listen Client responds. Server receives the response from client. Then server closes the socket in message publisher and remove the message listener from listener manager After all aboves steps, all sockets are closed and each listener thread (ServerListener in the client and ClientListener in the server) is terminated.\nTo Be Improved This system is built on BIO. In server and client sides, there is one thread blocked to listen to messages sent to the input stream of the socket. Thread is expensive because of the memory it occupies and performance influence when CPU switching among different threads Listener is a resource shared by two threads, main thread and the listener thread. Current code doesn’t ensure thread safety. The quick fix is to expose InputStream and OutputStream of the socket from the listener, and main thread can only access the two streams by calling the exposed methods. Also, the two methods should be synchronized. ",
  "wordCount" : "1273",
  "inLanguage": "en",
  "datePublished": "2023-11-26T21:26:33-08:00",
  "dateModified": "2023-11-26T21:26:33-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://whatsBehind.github.io/programming/project/online-chat/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "What's Behind",
    "logo": {
      "@type": "ImageObject",
      "url": "https://whatsBehind.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://whatsBehind.github.io/" accesskey="h" title="What&#39;s Behind (Alt + H)">What&#39;s Behind</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Online Chat
    </h1>
    <div class="post-meta"><span title='2023-11-26 21:26:33 -0800 PST'>November 26, 2023</span>

</div>
  </header> 
  <div class="post-content"><h2 id="demo">Demo<a hidden class="anchor" aria-hidden="true" href="#demo">#</a></h2>
<div class="container">
  <div id="player-wrapper" class="my-5"></div>
</div>

<script 
  type="text/javascript" 
  src="https://cdn.jsdelivr.net/npm/@clappr/player@latest/dist/clappr.min.js"
>
</script>

<script>
  var playerElement = document.getElementById("player-wrapper");

  var player = new Clappr.Player({
    source: "/programming/project/online-chat/demo.mp4",
    mute: true,
    height: 360,
    width: 640
  });

  player.attachTo(playerElement);  
</script>

<h2 id="high-level-architecture">High Level Architecture<a hidden class="anchor" aria-hidden="true" href="#high-level-architecture">#</a></h2>
<p>This is an online chat system built with BIO (Blocking IO) Using Java. Each client has two socket connections with the server, one connection supports message push mode and another one supports message pull mode.</p>
<p>The system now supports below features:</p>
<ul>
<li>Login</li>
<li>Pull online users</li>
<li>Online chat</li>
<li>Logoff</li>
</ul>
<p>Because of supports for push and pull modes, features like</p>
<ul>
<li>Upload/Download files</li>
<li>Group chat
can be easily added in the system. However, this project is just for learning purpose, so I didn&rsquo;t spend too much time on it.</li>
</ul>
<p><img loading="lazy" src="/programming/project/online-chat/online-chat-architecture.png" alt="image"  />
</p>
<h2 id="key-components">Key Components<a hidden class="anchor" aria-hidden="true" href="#key-components">#</a></h2>
<h3 id="client">Client<a hidden class="anchor" aria-hidden="true" href="#client">#</a></h3>
<ul>
<li>Server Listener</li>
</ul>
<p>It&rsquo;s basically a class extending <code>Thread</code> containing a socket connected with the server. In its <code>run()</code> method, it listens to <code>InputStream</code> of the socket which takes messages from the server. The socket in this component connects to <code>Publisher</code> from the server to support message push mode</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ServerListener</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Socket socket;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> listening <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ServerListener</span>(Socket socket, User user) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">socket</span> <span style="color:#f92672">=</span> socket;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> user;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(listening) {
</span></span><span style="display:flex;"><span>                ObjectInputStream ois <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream(socket.<span style="color:#a6e22e">getInputStream</span>());
</span></span><span style="display:flex;"><span>                Message response <span style="color:#f92672">=</span> (Message) ois.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>                MessageType type <span style="color:#f92672">=</span> response.<span style="color:#a6e22e">getType</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">switch</span>(type) {
</span></span><span style="display:flex;"><span>                    ... <span style="color:#75715e">// Operations</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (IOException <span style="color:#f92672">|</span> ClassNotFoundException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Online Chat Client</li>
</ul>
<p>It&rsquo;s a client class containing another socket connecting with the server. It supports message pull mode, which is that client sends a request to server and receives a response, and it&rsquo;s a synchronous request.
It has two private methods <code>sendRequest</code> and <code>receiveResponse</code> which are used to support communication with the server.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OnlineChatClient</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Socket client;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ObjectOutputStream oos;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ObjectInputStream ois;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sendRequest</span>(Message request) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream(client.<span style="color:#a6e22e">getOutputStream</span>());
</span></span><span style="display:flex;"><span>        oos.<span style="color:#a6e22e">writeObject</span>(request);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Message <span style="color:#a6e22e">receiveResponse</span>() <span style="color:#66d9ef">throws</span> IOException, ClassNotFoundException {
</span></span><span style="display:flex;"><span>        ois <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream(client.<span style="color:#a6e22e">getInputStream</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (Message) ois.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="server">Server<a hidden class="anchor" aria-hidden="true" href="#server">#</a></h3>
<ul>
<li>Message Publisher</li>
</ul>
<p>The name of this component is descriptive. Its duty is to publish a message to a corresponding client and receive the response from the server. It works with <code>Server Listener</code> in clients to support message push mode. Each message publisher has a 1 to 1 relationship with the client. All message publishers are managed by <code>Message Publisher Manager</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MessagePublisher</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Socket socket;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ObjectOutputStream oos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">publish</span>(Object o) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream(socket.<span style="color:#a6e22e">getOutputStream</span>());
</span></span><span style="display:flex;"><span>        oos.<span style="color:#a6e22e">writeObject</span>(o);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Message Publisher Manager</li>
</ul>
<p>It maintains a <code>Map</code> to store all message publishers. The map&rsquo;s key is user id and the value is the message publisher. It provides methods like <code>add()</code> <code>get(String userId)</code> and <code>delete(String userId)</code> to manage all message publishers.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MessagePublisherManager</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">static</span> Map<span style="color:#f92672">&lt;</span>String, MessagePublisher<span style="color:#f92672">&gt;</span> publishers <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">contains</span>(User user) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> String id <span style="color:#f92672">=</span> user.<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> publishers.<span style="color:#a6e22e">containsKey</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> MessagePublisher <span style="color:#a6e22e">add</span>(User user, Socket socket) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (contains(user)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> publishers.<span style="color:#a6e22e">get</span>(user);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> String id <span style="color:#f92672">=</span> user.<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        MessagePublisher publisher <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MessagePublisher(user, socket);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> MessagePublisherManager.<span style="color:#a6e22e">publishers</span>.<span style="color:#a6e22e">put</span>(id, publisher);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> MessagePublisher <span style="color:#a6e22e">get</span>(String userId) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> publishers.<span style="color:#a6e22e">get</span>(userId);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> MessagePublisher <span style="color:#a6e22e">get</span>(User user) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> get(user.<span style="color:#a6e22e">getId</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(User user) {
</span></span><span style="display:flex;"><span>        publishers.<span style="color:#a6e22e">remove</span>(user.<span style="color:#a6e22e">getId</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Client Listener</li>
</ul>
<p>It is similar to <code>Server Listener</code> in clients. It&rsquo;s a <code>Thread</code> subclass waiting for message from the server. The thread in the most time is blocked at line</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>Message response <span style="color:#f92672">=</span> (Message) ois.<span style="color:#a6e22e">readObject</span>();
</span></span></code></pre></div><p>Once messages sent to the socket&rsquo;s receive queue (<code>InputStream</code>), it reads the message and performs corresponding operation and returns a response to the client.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClientListener</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Socket socket;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ObjectOutputStream oos;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> listening <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(listening) {
</span></span><span style="display:flex;"><span>                ObjectInputStream ois <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream(socket.<span style="color:#a6e22e">getInputStream</span>());
</span></span><span style="display:flex;"><span>                Message response <span style="color:#f92672">=</span> (Message) ois.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>                MessageType type <span style="color:#f92672">=</span> response.<span style="color:#a6e22e">getType</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">switch</span>(type) {
</span></span><span style="display:flex;"><span>                    ... <span style="color:#75715e">// Operations</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (IOException <span style="color:#f92672">|</span> ClassNotFoundException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sendResponse</span>(Message message) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream(socket.<span style="color:#a6e22e">getOutputStream</span>());
</span></span><span style="display:flex;"><span>        oos.<span style="color:#a6e22e">writeObject</span>(message);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Client Listener Manager</li>
</ul>
<p>It manages all client listeners in a <code>Map</code>, supporting methods like <code>add</code>, <code>get</code> and <code>remove</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClientListenerManager</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">static</span> Map<span style="color:#f92672">&lt;</span>String, ClientListener<span style="color:#f92672">&gt;</span> clientListeners <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> ObjectOutputStream oos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(Socket socket, User user) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        Message response <span style="color:#f92672">=</span> Message.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">type</span>(MessageType.<span style="color:#a6e22e">CONNECT</span>)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">content</span>(gson.<span style="color:#a6e22e">toJson</span>(BaseResponse.<span style="color:#a6e22e">builder</span>().<span style="color:#a6e22e">successful</span>(<span style="color:#66d9ef">true</span>).<span style="color:#a6e22e">build</span>()))
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">timeStamp</span>(<span style="color:#66d9ef">new</span> Date().<span style="color:#a6e22e">toString</span>()).<span style="color:#a6e22e">build</span>();
</span></span><span style="display:flex;"><span>        oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream(socket.<span style="color:#a6e22e">getOutputStream</span>());
</span></span><span style="display:flex;"><span>        oos.<span style="color:#a6e22e">writeObject</span>(response);
</span></span><span style="display:flex;"><span>        ClientListener listener <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ClientListener(socket, user);
</span></span><span style="display:flex;"><span>        clientListeners.<span style="color:#a6e22e">put</span>(user.<span style="color:#a6e22e">getId</span>(), listener);
</span></span><span style="display:flex;"><span>        listener.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ClientListener <span style="color:#a6e22e">get</span>(User user) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> String id <span style="color:#f92672">=</span> user.<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> clientListeners.<span style="color:#a6e22e">get</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ClientListener <span style="color:#a6e22e">get</span>(String id) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> clientListeners.<span style="color:#a6e22e">get</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(User user) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> String id <span style="color:#f92672">=</span> user.<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        clientListeners.<span style="color:#a6e22e">remove</span>(id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="supported-features">Supported Features<a hidden class="anchor" aria-hidden="true" href="#supported-features">#</a></h2>
<h3 id="login">Login<a hidden class="anchor" aria-hidden="true" href="#login">#</a></h3>
<ul>
<li>Client creates a new <code>Socket</code> connecting to port <code>9999</code> in local host (Server and clients are in local host) by sending below message.
<ul>
<li>Message type is <code>USER_LOGIN</code></li>
<li>Before sending the message, user needs to enter user id and password</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>Message request <span style="color:#f92672">=</span> Message.<span style="color:#a6e22e">builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">sender</span>(user.<span style="color:#a6e22e">getId</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">timeStamp</span>(<span style="color:#66d9ef">new</span> Date().<span style="color:#a6e22e">toString</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">type</span>(MessageType.<span style="color:#a6e22e">USER_LOGIN</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">content</span>(gson.<span style="color:#a6e22e">toJson</span>(user))
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>();
</span></span></code></pre></div></li>
</ul>
<p><img loading="lazy" src="/programming/project/online-chat/login1.png" alt="image"  />
</p>
<ul>
<li>Server receives the login message from the client
<ul>
<li>First server checks database if the user enters valid user id and password (Not implemented)</li>
<li>After id and password validations, server creates a new <code>MessagePublisher</code> and add it into <code>MessagePublisherManager</code></li>
<li>In the end, server sends back a response to notify the client if login succeeds</li>
</ul>
</li>
<li>Client receives response from server. If login succeeded, client start a new <code>ServerListener</code> which is a subclass of <code>Thread</code> to listen to message from server. The thread is blocked when there is no messages from server.
<img loading="lazy" src="/programming/project/online-chat/login2.png" alt="image"  />
</li>
</ul>
<h3 id="connect">Connect:<a hidden class="anchor" aria-hidden="true" href="#connect">#</a></h3>
<p>This is not an API, but a process implicitly done in advance for features like <code>GetOnlineUsers</code> which utilizes <code>OnlineChatClient</code></p>
<ul>
<li>Client creates a new <code>Socket</code> connecting to port <code>9999</code> in local host
<img loading="lazy" src="/programming/project/online-chat/connect1.png" alt="image"  />
</li>
<li>After server receives the request,
<ul>
<li>it starts a new <code>ClientListener</code>, the subclass of <code>Thread</code>, which is listening message from the client.</li>
<li>Then server add the <code>ClientListener</code> to <code>ClientListenerManager</code></li>
<li>Server send back response to the client</li>
</ul>
</li>
<li>Client receives response from server
<img loading="lazy" src="/programming/project/online-chat/connect2.png" alt="image"  />
</li>
</ul>
<p>After above steps, a new socket connection between server and client is built, which supports message pull mode.</p>
<h3 id="getonlineusers">GetOnlineUsers<a hidden class="anchor" aria-hidden="true" href="#getonlineusers">#</a></h3>
<ul>
<li>Client sends a request to server</li>
<li>Server checks <code>MessagePublisherManager</code>, get all online users&rsquo; id</li>
<li>Server sends a response back to client</li>
<li>Client renders online users&rsquo; id in terminal</li>
</ul>
<p><img loading="lazy" src="/programming/project/online-chat/pull-online-users.png" alt="image"  />
</p>
<h3 id="chat">Chat<a hidden class="anchor" aria-hidden="true" href="#chat">#</a></h3>
<ul>
<li>ClientA sends a request to server containing receiver&rsquo;s id (ClientB) and the message</li>
<li>Client listenerA in the server receives the request, it passes the message to message publisherB</li>
<li>Message publisherB sends a request containing the message to clientB</li>
<li>ClientB responds after receiving the message</li>
<li>After message was successfully sent to clientB, client listenerA sends a response to clientA</li>
<li>ClientA receives the response</li>
</ul>
<p><img loading="lazy" src="/programming/project/online-chat/chat.png" alt="image"  />
</p>
<h3 id="logoff">Logoff<a hidden class="anchor" aria-hidden="true" href="#logoff">#</a></h3>
<p><img loading="lazy" src="/programming/project/online-chat/logoff1.png" alt="image"  />
</p>
<ul>
<li>Client sends a request to the server to logoff</li>
<li>Server receives the request, responds to the client.</li>
<li>Server close the socket in the client listener, and remove the listener from listener manager</li>
<li>Server sends a request to client through message publisher</li>
<li>Client receives the request, close socket in the server listen</li>
<li>Client responds. Server receives the response from client. Then server closes the socket in message publisher and remove the message listener from listener manager</li>
</ul>
<p>After all aboves steps, all sockets are closed and each listener thread (<code>ServerListener</code> in the client and <code>ClientListener</code> in the server) is terminated.</p>
<p><img loading="lazy" src="/programming/project/online-chat/logoff2.png" alt="image"  />
</p>
<h2 id="to-be-improved">To Be Improved<a hidden class="anchor" aria-hidden="true" href="#to-be-improved">#</a></h2>
<ul>
<li>This system is built on BIO. In server and client sides, there is one thread blocked to listen to messages sent to the input stream of the socket. Thread is expensive because of the memory it occupies and performance influence when CPU switching among different threads</li>
<li>Listener is a resource shared by two threads, main thread and the listener thread. Current code doesn&rsquo;t ensure thread safety. The quick fix is to expose <code>InputStream</code> and <code>OutputStream</code> of the socket from the listener, and main thread can only access the two streams by calling the exposed methods. Also, the two methods should be synchronized.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://whatsBehind.github.io/">What&#39;s Behind</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
